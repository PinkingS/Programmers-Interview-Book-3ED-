#第11章 继承与接口#

##11.1 覆盖##

**面试例题1**

+ 构造函数从最开始的基类开始构造，各个类的同名变量没有形成覆盖，都是单独的变量

+ 就近调用原则：

	+ 自己没有找父辈，如果父辈存在相关接口则优先调用父辈接口，父辈没有再往上找。（向上找到第一个实现的接口）
	+ 如果接口是虚函数，需要根据准确的对象类型来调用（向下找到离自己最近的实现接口）
	+ 接口里返回的是当前类的成员变量
	+ 如果显式表明调用那个类的接口，如`c.A::doGetData()`，虚函数规则失效，就调用指定类的接口。

##11.2 私有继承##

**面试例题1**

私有继承：

+ 从派生类的使用者来讲，所有的基类方法和成员都是private的，不可访问（可以继承，只是无法访问）
+ 从派生类内部来讲，除了基类的private的方法和成员，其他的都可以访问
+ 无论派生类是公有继承还是私有继承，基类的private方法和成员都不可以访问

在无继承的类中，public和private是没有区别的，类自己的成员函数能够访问自己的public或者private成员。在继承中，基类的private对所有外界都屏蔽（包括自己的派生类），基类的protected控制符对应用程序是屏蔽的，但对其派生类是可访问的。

总结如图：


##11.3 虚函数继承和虚继承##

虚继承又叫作共享继承，是为了解决多重继承中出现的问题。虚基类是共享的，也就是在继承体系中无论被继承多少次，对象内存中均只会出现一个虚基类的子对象。

关于虚函数继承：
http://www.cnblogs.com/Ripper-Y/archive/2012/05/15/2501930.html

##11.7 运算符重载与RTTI##

**面试例题4**

关于运算符重载：

+ 如果运算符被定义为全局函数，则对于一元运算符是一个参数，对于二元运算符是两个参数
+ 如果运算符被定义为成员函数，则对于一元运算符没有参数，对于二元运算符是一个参数

