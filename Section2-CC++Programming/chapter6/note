关于结构体对齐的问题

一般会按字对齐，即中间有个char，它会占4个字节，如果中间有两个char，那么两个char会一起占4个字节。

6.1

面试例题1

上面定义的FIND宏就是要的e的偏移。这样强制转换后的结构指针怎么可以用来访问结构体字段？其实这个表达式根本没有也不打算访问e字段。ANSI C标准允许任何值为0的常量被强制转换成任何一种类型的指针，并且转换结果是一个NULL指针，因此((struct*)0)的结果就是一个类型为struct*的NULL指针。如果利用这个NULL指针来访问struct的成员当然是非法的，但&(((struct*)0)->e)的意图并非想存取e字段内容，而仅仅是计算当结构体实例的首址为((struct*)0)时e字段的地址。聪明的编译器根本就不生成访问e的代码，而仅仅是根据struct的内存布局和结构体实例首址在编译期计算这个(常量)地址，这样就完全避免了通过NULL指针访问内存的问题。又因为首址的值为0，所以这个地址的值就是字段相对于结构体基址的偏移。

扩展一下，现在知道这个变量的地址，求结构体的首地址

#define FIND(struct,pt,e ) ((size_t)pt-(size_t)(&(((struct*)0)->e)))

面试例题2

这道题里需要注意的有几点：

+ `#define`的变量不是必须大写，但为了区分局部变量，定义的常量一般用大写字母表示
+ 16位机器能表示的最大unsigned int值是`2^16-1`即65535，最大signed int值是`2^15-1`即32767
+ 32位机器能表示的最大unsigned int值是`2^32-1`即4294967295，大约42亿，signed int最大能表示大约21亿。

面试例题3

宏定义中的参数最好加括号，因为宏替换就是简单的文本替换，加括号是为了处理表达式参数(参数可能是算法表达式)，使之更加通用。

例如，如果下面的宏定义参数不加括号：

```#define COM(A+B) A*B

那么COM(1+2,3)会得到错误的结果

6.2

面试例题1

将const修饰的常量说成是'只读变量'更好一些。

c const关键字理解
http://blog.csdn.net/mcgrady_tracy/article/details/8517951

C、C++中const关键字理解
http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777416.html

const修饰指针要从右往左读。

面试例题2

const和\#define的区别补充几点：

+ define宏是在预处理阶段展开的，const常量在编译运行阶段使用。
+ const定义的只读变量是有数据类型的，编译器可以对其进行数据类型检查，而#define宏定义的常量只是进行简单的字符`替换`，没有类型检查，且有时还会产生边际效应。
+ 有些调试程序可对const进行调试，但不对#define进行调试。
+ 当定义局部变量时，const作用域仅限于定义局部变量的函数体内。但用#define时其作用域不仅限于定义局部变量的函数体内，而是从定义点到整个程序的结束点。但也可以用#undef取消其定义从而限定其作用域范围。

另外：

C++中支持\#define是因为要兼容C，C++中不提倡用\#define来定义常量.

\#define也可以定义带参数的宏，C++中使用inline函数来代替。

补充关于指针和引用的一点：

指针和引用的区别很简单，就是引用更简洁，更安全。因为引用声明是必须初始化。 引用更接近const指针，一旦与某个变量关联，就将一直效忠于他。

补充关于const指针的一点：

const指针可以接受const和非const地址，但是非const指针只能接受非const地址。所以const指针的能力更强一些，所以尽量多用const指针，这是一种习惯。

Const和＃define大比拼
http://www.programfan.com/blog/article.asp?id=28476

6.3

面试例题2

解析中‘这个结构的尺寸是sizeof(char)+sizeof(int)=6’应该是5，sizeof(char)为1.

面试例题3

‘静态变量存放在全局数据区，sizeof计算栈中分配的大小，所以static的不计算在内.

最后一个sizeof(A5)应该等于20，不是24.

---------------------------------------------------
[小邱同志tips:]
struct{}后面一定要带;
struct有两种形式：
单独定义struct A{};
附带别名 typedef struct A{}B,*pa...;
数组只有在作为函数的传入参数时才会退化为指针，即sizeof为4
声明数组时前面带的*都是指的数组元素是指针，如int *A[3], int **b[3][4]...
int a[3];
int* pa = a;
int** ppa = &pa;
----------------------------------------------

面试例题7

sizeof(string)=4;
sizeof(strArr)=12;

可以理解为string是一个指针，指向字符串首地址，strArr是个string数组，包含三个string对象，即三个指针。

若string str="lskdjflskdjglskjfld";
sizeof(str)=4;因为sizeof会将括号中的内容替代为类型，就是sizeof(string),str多长sizeof出来都是4.

char* ss1="123456789";  //sizeof(ss1)=4; sizeof(*ss1)=1;
char ss2[] = "123456789"; //sizeof(ss2)=10;

面试例题8

关于类的大小：
+类的大小为类的非静态成员数据的类型大小之和，静态成员数据不作考虑
+空类的大小为1，单一继承和多重继承的空类空间为1，虚继承为4
+构造函数，析构函数及普通的成员函数跟sizeof无关
+带有虚函数的类，因为要维护一个虚函数表所以占用一个指针的空间4
+子类如果是重新实现的父类的虚函数，不计入sizeof大小

面试例题8

宏和函数的区别：
+宏是简单的字符串替换，没有参数类型检查，内联函数要做参数类型检查
+宏在编译之前进行，即先用宏体替换宏名，然后再编译。函数是编译之后，在执行时调用的。所以宏占用的是编译的时间，函数占用的是执行时的时间。
+宏的参数不占内存空间，因为只是简单的字符串替换。函数的形参会占内存空间。
+函数要有调用开销，宏没有。

关于“内联函数”

内联函数省去了上面列出的最后一点，节约下原本函数调用时的时空开销。但必须注意的是，作为内联函数，函数体必须十分简单，不能含有循环、条件、选择等复杂的结构。具体是否能嵌入由编译器决定。事实上，即便没有指定为内联函数，有的编译系统也会自动将很简单的函数作为内联函数处理，而对于复杂的函数，即便指定为内联函数，系统也不会理会。






