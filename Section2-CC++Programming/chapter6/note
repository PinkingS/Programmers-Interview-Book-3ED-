关于结构体对齐的问题

一般会按字对齐，即中间有个char，它会占4个字节，如果中间有两个char，那么两个char会一起占4个字节。

6.1

面试例题1

上面定义的FIND宏就是要的e的偏移。这样强制转换后的结构指针怎么可以用来访问结构体字段？其实这个表达式根本没有也不打算访问e字段。ANSI C标准允许任何值为0的常量被强制转换成任何一种类型的指针，并且转换结果是一个NULL指针，因此((struct*)0)的结果就是一个类型为struct*的NULL指针。如果利用这个NULL指针来访问struct的成员当然是非法的，但&(((struct*)0)->e)的意图并非想存取e字段内容，而仅仅是计算当结构体实例的首址为((struct*)0)时e字段的地址。聪明的编译器根本就不生成访问e的代码，而仅仅是根据struct的内存布局和结构体实例首址在编译期计算这个(常量)地址，这样就完全避免了通过NULL指针访问内存的问题。又因为首址的值为0，所以这个地址的值就是字段相对于结构体基址的偏移。

扩展一下，现在知道这个变量的地址，求结构体的首地址

#define FIND(struct,pt,e ) ((size_t)pt-(size_t)(&(((struct*)0)->e)))

面试例题2

这道题里需要注意的有几点：

+ `#define`的变量不是必须大写，但为了区分局部变量，定义的常量一般用大写字母表示
+ 16位机器能表示的最大unsigned int值是`2^16-1`即65535，最大signed int值是`2^15-1`即32767
+ 32位机器能表示的最大unsigned int值是`2^32-1`即4294967295，大约42亿，signed int最大能表示大约21亿。

面试例题3

宏定义中的参数最好加括号，因为宏替换就是简单的文本替换，加括号是为了处理表达式参数(参数可能是算法表达式)，使之更加通用。

例如，如果下面的宏定义参数不加括号：

```#define COM(A+B) A*B

那么COM(1+2,3)会得到错误的结果


